#!/usr/bin/env python3
"""
Maternal Health Risk Prediction System - FastAPI Implementation
============================================================
Professional REST API for healthcare integration and production deployment.

Features:
- RESTful API endpoints for ML predictions
- Authentication and authorization
- Rate limiting and caching
- Comprehensive error handling
- API documentation with OpenAPI/Swagger
- Database integration
- Monitoring and logging

Author: Senior AI Healthcare Engineer
Version: 2.1.0
"""

import asyncio
import logging
import time
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any
import json
import uuid

from fastapi import FastAPI, HTTPException, Depends, status, BackgroundTasks, Request
from fastapi.middleware.cors import CORSMiddleware
from fastapi.middleware.trustedhost import TrustedHostMiddleware
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from fastapi.responses import JSONResponse
from pydantic import BaseModel, Field, validator
import uvicorn

# Database and Caching
from sqlalchemy import create_engine, Column, Integer, String, Float, DateTime, Text, Boolean
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker, Session
import redis
from databases import Database

# Authentication and Security
import jwt
from passlib.context import CryptContext
from passlib.hash import bcrypt

# Monitoring
from prometheus_client import Counter, Histogram, generate_latest
import sentry_sdk
from sentry_sdk.integrations.fastapi import FastApiIntegration

# Application imports
from maternal_health_app import (
    EnsemblePredictor, DataProcessor, NLPAnalyzer, 
    HealthcareAgent, ConfigManager, RealTimeMonitor
)

# Initialize FastAPI app
app = FastAPI(
    title="Maternal Health Risk Prediction API",
    description="Advanced AI-powered healthcare tool for maternal risk assessment",
    version="2.1.0",
    docs_url="/docs",
    redoc_url="/redoc",
    openapi_url="/openapi.json"
)

# Security
security = HTTPBearer()
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

# Database setup
DATABASE_URL = "postgresql://user:password@localhost:5432/maternal_health"
database = Database(DATABASE_URL)
engine = create_engine(DATABASE_URL)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()

# Redis for caching
redis_client = redis.Redis(host='localhost', port=6379, db=0, decode_responses=True)

# Monitoring metrics
REQUEST_COUNT = Counter('requests_total', 'Total requests', ['method', 'endpoint', 'status'])
REQUEST_DURATION = Histogram('request_duration_seconds', 'Request duration')
PREDICTION_COUNT = Counter('predictions_total', 'Total predictions', ['risk_level'])

# Initialize core components
config_manager = ConfigManager()
data_processor = DataProcessor(config_manager)
predictor = EnsemblePredictor(config_manager)
nlp_analyzer = NLPAnalyzer()
healthcare_agent = HealthcareAgent(predictor, nlp_analyzer)
monitor = RealTimeMonitor(config_manager)

# Database Models
class User(Base):
    __tablename__ = "users"
    
    id = Column(Integer, primary_key=True, index=True)
    username = Column(String, unique=True, index=True)
    email = Column(String, unique=True, index=True)
    hashed_password = Column(String)
    role = Column(String, default="user")
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)

class PredictionLog(Base):
    __tablename__ = "prediction_logs"
    
    id = Column(Integer, primary_key=True, index=True)
    session_id = Column(String, index=True)
    user_id = Column(Integer, index=True)
    input_data = Column(Text)
    prediction_result = Column(Text)
    risk_level = Column(String)
    confidence = Column(Float)
    timestamp = Column(DateTime, default=datetime.utcnow)
    processing_time = Column(Float)

class AuditLog(Base):
    __tablename__ = "audit_logs"
    
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, index=True)
    action = Column(String)
    resource = Column(String)
    details = Column(Text)
    ip_address = Column(String)
    timestamp = Column(DateTime, default=datetime.utcnow)

# Pydantic Models
class PatientData(BaseModel):
    age: int = Field(..., ge=15, le=50, description="Patient age in years")
    systolic_bp: int = Field(..., ge=80, le=200, description="Systolic blood pressure")
    diastolic_bp: int = Field(..., ge=40, le=120, description="Diastolic blood pressure")
    blood_sugar: float = Field(..., ge=60, le=300, description="Blood sugar level")
    body_temp: float = Field(..., ge=96, le=104, description="Body temperature in Fahrenheit")
    heart_rate: int = Field(..., ge=50, le=150, description="Heart rate in BPM")
    previous_complications: bool = Field(default=False, description="Previous pregnancy complications")
    family_history: bool = Field(default=False, description="Family history of diabetes/hypertension")
    multiple_pregnancy: bool = Field(default=False, description="Multiple pregnancy (twins, etc.)")
    
    @validator('systolic_bp')
    def validate_systolic_bp(cls, v, values):
        if 'diastolic_bp' in values and v <= values['diastolic_bp']:
            raise ValueError('Systolic BP must be higher than diastolic BP')
        return v

class ClinicalNotes(BaseModel):
    notes: str = Field(..., min_length=10, max_length=5000, description="Clinical notes text")
    language: str = Field(default="en", description="Language of the notes")
    
class ChatMessage(BaseModel):
    message: str = Field(..., min_length=1, max_length=1000, description="Chat message")
    session_id: Optional[str] = Field(None, description="Session ID for conversation continuity")
    patient_context: Optional[PatientData] = Field(None, description="Patient data for context")

class UserCreate(BaseModel):
    username: str = Field(..., min_length=3, max_length=50)
    email: str = Field(..., regex=r'^[\w\.-]+@[\w\.-]+\.\w+$')
    password: str = Field(..., min_length=8, max_length=100)
    role: str = Field(default="user", regex=r'^(user|admin|doctor|nurse)$')

class UserLogin(BaseModel):
    username: str
    password: str

class PredictionResponse(BaseModel):
    status: str
    data: Dict[str, Any]
    timestamp: datetime
    session_id: str
    processing_time: float

class HealthCheck(BaseModel):
    status: str
    timestamp: datetime
    version: str
    database: str
    models: str
    cache: str

# Middleware
@app.middleware("http")
async def add_process_time_header(request: Request, call_next):
    start_time = time.time()
    response = await call_next(request)
    process_time = time.time() - start_time
    response.headers["X-Process-Time"] = str(process_time)
    
    # Update metrics
    REQUEST_DURATION.observe(process_time)
    REQUEST_COUNT.labels(
        method=request.method,
        endpoint=request.url.path,
        status=response.status_code
    ).inc()
    
    return response

# CORS configuration
app.add_middleware(
    CORSMiddleware,
    allow_origins=["https://maternal-health-app.com", "http://localhost:3000"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Trusted hosts
app.add_middleware(
    TrustedHostMiddleware,
    allowed_hosts=["maternal-health-api.com", "*.maternal-health-api.com", "localhost"]
)

# Database dependency
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# Authentication functions
def verify_password(plain_password: str, hashed_password: str) -> bool:
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password: str) -> str:
    return pwd_context.hash(password)

def create_access_token(data: dict, expires_delta: Optional[timedelta] = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(hours=24)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, "SECRET_KEY", algorithm="HS256")
    return encoded_jwt

async def get_current_user(credentials: HTTPAuthorizationCredentials = Depends(security), 
                          db: Session = Depends(get_db)):
    try:
        payload = jwt.decode(credentials.credentials, "SECRET_KEY", algorithms=["HS256"])
        username: str = payload.get("sub")
        if username is None:
            raise HTTPException(status_code=401, detail="Invalid authentication credentials")
    except jwt.PyJWTError:
        raise HTTPException(status_code=401, detail="Invalid authentication credentials")
    
    user = db.query(User).filter(User.username == username).first()
    if user is None:
        raise HTTPException(status_code=401, detail="User not found")
    return user

# Utility functions
def log_prediction(db: Session, user_id: int, input_data: dict, result: dict, 
                  processing_time: float, session_id: str):
    """Log prediction for audit trail."""
    prediction_log = PredictionLog(
        session_id=session_id,
        user_id=user_id,
        input_data=json.dumps(input_data),
        prediction_result=json.dumps(result),
        risk_level=result.get('prediction', {}).get('risk_level', 'Unknown'),
        confidence=result.get('prediction', {}).get('confidence', 0.0),
        processing_time=processing_time
    )
    db.add(prediction_log)
    db.commit()

def log_audit(db: Session, user_id: int, action: str, resource: str, 
              details: str, ip_address: str):
    """Log user actions for security audit."""
    audit_log = AuditLog(
        user_id=user_id,
        action=action,
        resource=resource,
        details=details,
        ip_address=ip_address
    )
    db.add(audit_log)
    db.commit()

# API Endpoints

@app.on_event("startup")
async def startup_event():
    """Initialize application on startup."""
    await database.connect()
    Base.metadata.create_all(bind=engine)
    
    # Initialize ML models (in production, load pre-trained models)
    logging.info("Initializing ML models...")
    
    # Initialize Sentry for error tracking
    sentry_sdk.init(
        dsn="YOUR_SENTRY_DSN",
        integrations=[FastApiIntegration(auto_enable=True)],
        traces_sample_rate=0.1,
    )
    
    logging.info("Application startup complete")

@app.on_event("shutdown")
async def shutdown_event():
    """Cleanup on application shutdown."""
    await database.disconnect()
    logging.info("Application shutdown complete")

@app.get("/", response_model=Dict[str, str])
async def root():
    """Root endpoint with API information."""
    return {
        "message": "Maternal Health Risk Prediction API",
        "version": "2.1.0",
        "status": "active",
        "docs": "/docs",
        "health": "/health"
    }

@app.get("/health", response_model=HealthCheck)
async def health_check():
    """Comprehensive health check endpoint."""
    try:
        # Check database
        db_status = "healthy"
        try:
            await database.fetch_one("SELECT 1")
        except:
            db_status = "unhealthy"
        
        # Check Redis cache
        cache_status = "healthy"
        try:
            redis_client.ping()
        except:
            cache_status = "unhealthy"
        
        # Check models
        models_status = "healthy"
        if not hasattr(predictor, 'ensemble') or predictor.ensemble is None:
            models_status = "uninitialized"
        
        overall_status = "healthy" if all(s == "healthy" for s in [db_status, cache_status, models_status]) else "degraded"
        
        return HealthCheck(
            status=overall_status,
            timestamp=datetime.utcnow(),
            version="2.1.0",
            database=db_status,
            models=models_status,
            cache=cache_status
        )
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Health check failed: {str(e)}")

@app.post("/auth/register", response_model=Dict[str, str])
async def register_user(user: UserCreate, db: Session = Depends(get_db)):
    """Register a new user."""
    # Check if user already exists
    existing_user = db.query(User).filter(
        (User.username == user.username) | (User.email == user.email)
    ).first()
    
    if existing_user:
        raise HTTPException(status_code=400, detail="Username or email already registered")
    
    # Create new user
    hashed_password = get_password_hash(user.password)
    db_user = User(
        username=user.username,
        email=user.email,
        hashed_password=hashed_password,
        role=user.role
    )
    db.add(db_user)
    db.commit()
    db.refresh(db_user)
    
    return {"message": "User registered successfully", "user_id": str(db_user.id)}

@app.post("/auth/login", response_model=Dict[str, str])
async def login_user(user: UserLogin, request: Request, db: Session = Depends(get_db)):
    """Authenticate user and return access token."""
    db_user = db.query(User).filter(User.username == user.username).first()
    
    if not db_user or not verify_password(user.password, db_user.hashed_password):
        # Log failed login attempt
        log_audit(db, 0, "LOGIN_FAILED", "auth", f"Failed login for {user.username}", 
                 request.client.host)
        raise HTTPException(status_code=401, detail="Invalid credentials")
    
    if not db_user.is_active:
        raise HTTPException(status_code=401, detail="User account is disabled")
    
    # Create access token
    access_token = create_access_token(data={"sub": db_user.username})
    
    # Log successful login
    log_audit(db, db_user.id, "LOGIN_SUCCESS", "auth", "Successful login", 
             request.client.host)
    
    return {
        "access_token": access_token,
        "token_type": "bearer",
        "user_id": str(db_user.id),
        "role": db_user.role
    }

@app.post("/api/v1/predict", response_model=PredictionResponse)
async def predict_risk(
    patient_data: PatientData,
    background_tasks: BackgroundTasks,
    request: Request,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """
    Predict maternal health risk based on patient data.
    
    This endpoint uses an ensemble of machine learning models to assess
    maternal health risks and provides explainable AI insights.
    """
    session_id = str(uuid.uuid4())
    start_time = time.time()
    
    try:
        # Check cache first
        cache_key = f"prediction:{hash(str(patient_data.dict()))}"
        cached_result = redis_client.get(cache_key)
        
        if cached_result:
            result = json.loads(cached_result)
            processing_time = 0.001  # Cached response
        else:
            # Prepare input data
            input_array = [
                patient_data.age,
                patient_data.systolic_bp,
                patient_data.diastolic_bp,
                patient_data.blood_sugar,
                patient_data.body_temp,
                patient_data.heart_rate,
                int(patient_data.previous_complications),
                int(patient_data.family_history),
                int(patient_data.multiple_pregnancy)
            ]
            
            # Make prediction
            result = predictor.predict_with_explanation(np.array(input_array).reshape(1, -1))
            processing_time = time.time() - start_time
            
            # Cache result for 1 hour
            redis_client.setex(cache_key, 3600, json.dumps(result))
        
        # Update metrics
        PREDICTION_COUNT.labels(risk_level=result['prediction']['risk_level']).inc()
        
        # Log prediction in background
        background_tasks.add_task(
            log_prediction, db, current_user.id, patient_data.dict(), 
            result, processing_time, session_id
        )
        
        # Log audit trail
        background_tasks.add_task(
            log_audit, db, current_user.id, "PREDICTION", "predict", 
            f"Risk prediction for session {session_id}", request.client.host
        )
        
        return PredictionResponse(
            status="success",
            data=result,
            timestamp=datetime.utcnow(),
            session_id=session_id,
            processing_time=processing_time
        )
        
    except Exception as e:
        logging.error(f"Prediction error: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Prediction failed: {str(e)}")

@app.post("/api/v1/analyze-notes", response_model=Dict[str, Any])
async def analyze_clinical_notes(
    notes: ClinicalNotes,
    background_tasks: BackgroundTasks,
    request: Request,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """
    Analyze clinical notes using NLP to extract risk factors and insights.
    
    This endpoint processes clinical text to identify medical entities,
    risk factors, sentiment, and urgency indicators.
    """
    start_time = time.time()
    
    try:
        # Check cache
        cache_key = f"nlp_analysis:{hash(notes.notes)}"
        cached_result = redis_client.get(cache_key)
        
        if cached_result:
            analysis = json.loads(cached_result)
        else:
            # Perform NLP analysis
            analysis = nlp_analyzer.analyze_clinical_notes(notes.notes)
            
            # Cache result for 30 minutes
            redis_client.setex(cache_key, 1800, json.dumps(analysis))
        
        processing_time = time.time() - start_time
        
        # Log audit trail
        background_tasks.add_task(
            log_audit, db, current_user.id, "NLP_ANALYSIS", "analyze-notes",
            f"Clinical notes analysis", request.client.host
        )
        
        return {
            "status": "success",
            "data": analysis,
            "timestamp": datetime.utcnow(),
            "processing_time": processing_time,
            "language": notes.language
        }
        
    except Exception as e:
        logging.error(f"NLP analysis error: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Analysis failed: {str(e)}")

@app.post("/api/v1/chat", response_model=Dict[str, Any])
async def chat_with_agent(
    chat: ChatMessage,
    background_tasks: BackgroundTasks,
    request: Request,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """
    Chat with the AI healthcare agent for medical insights and guidance.
    
    The agent can provide information about maternal health, risk factors,
    recommendations, and answer clinical questions.
    """
    start_time = time.time()
    session_id = chat.session_id or str(uuid.uuid4())
    
    try:
        # Process patient context if provided
        patient_data = None
        if chat.patient_context:
            patient_data = chat.patient_context.dict()
        
        # Get agent response
        response = healthcare_agent.process_query(chat.message, patient_data)
        processing_time = time.time() - start_time
        
        # Store conversation in cache for session continuity
        conversation_key = f"conversation:{session_id}"
        conversation = redis_client.get(conversation_key)
        
        if conversation:
            conversation_data = json.loads(conversation)
        else:
            conversation_data = {"messages": []}
        
        conversation_data["messages"].extend([
            {"role": "user", "content": chat.message, "timestamp": datetime.utcnow().isoformat()},
            {"role": "assistant", "content": response, "timestamp": datetime.utcnow().isoformat()}
        ])
        
        # Keep only last 20 messages
        conversation_data["messages"] = conversation_data["messages"][-20:]
        
        # Cache for 2 hours
        redis_client.setex(conversation_key, 7200, json.dumps(conversation_data))
        
        # Log audit trail
        background_tasks.add_task(
            log_audit, db, current_user.id, "CHAT", "chat",
            f"Chat interaction in session {session_id}", request.client.host
        )
        
        return {
            "status": "success",
            "data": {
                "response": response,
                "session_id": session_id,
                "conversation_length": len(conversation_data["messages"])
            },
            "timestamp": datetime.utcnow(),
            "processing_time": processing_time
        }
        
    except Exception as e:
        logging.error(f"Chat error: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Chat failed: {str(e)}")

@app.get("/api/v1/conversation/{session_id}", response_model=Dict[str, Any])
async def get_conversation_history(
    session_id: str,
    current_user: User = Depends(get_current_user)
):
    """Get conversation history for a specific session."""
    try:
        conversation_key = f"conversation:{session_id}"
        conversation = redis_client.get(conversation_key)
        
        if not conversation:
            raise HTTPException(status_code=404, detail="Conversation not found")
        
        conversation_data = json.loads(conversation)
        
        return {
            "status": "success",
            "data": conversation_data,
            "session_id": session_id,
            "timestamp": datetime.utcnow()
        }
        
    except json.JSONDecodeError:
        raise HTTPException(status_code=500, detail="Invalid conversation data")
    except Exception as e:
        logging.error(f"Conversation retrieval error: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Failed to retrieve conversation: {str(e)}")

@app.post("/api/v1/monitoring/start", response_model=Dict[str, str])
async def start_patient_monitoring(
    patient_id: str,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Start real-time monitoring for a patient."""
    try:
        # Simulate data stream function
        def mock_data_stream():
            return {
                'heart_rate': np.random.normal(75, 10),
                'systolic_bp': np.random.normal(120, 15),
                'diastolic_bp': np.random.normal(80, 10),
                'temperature': np.random.normal(98.6, 1),
                'blood_sugar': np.random.normal(100, 20)
            }
        
        monitor.start_monitoring(patient_id, mock_data_stream)
        
        # Log audit trail
        log_audit(db, current_user.id, "START_MONITORING", "monitoring",
                 f"Started monitoring for patient {patient_id}", "system")
        
        return {
            "status": "success",
            "message": f"Monitoring started for patient {patient_id}",
            "patient_id": patient_id
        }
        
    except Exception as e:
        logging.error(f"Monitoring start error: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Failed to start monitoring: {str(e)}")

@app.post("/api/v1/monitoring/stop", response_model=Dict[str, str])
async def stop_patient_monitoring(
    patient_id: str,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Stop real-time monitoring for a patient."""
    try:
        monitor.stop_monitoring(patient_id)
        
        # Log audit trail
        log_audit(db, current_user.id, "STOP_MONITORING", "monitoring",
                 f"Stopped monitoring for patient {patient_id}", "system")
        
        return {
            "status": "success",
            "message": f"Monitoring stopped for patient {patient_id}",
            "patient_id": patient_id
        }
        
    except Exception as e:
        logging.error(f"Monitoring stop error: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Failed to stop monitoring: {str(e)}")

@app.get("/api/v1/monitoring/alerts", response_model=Dict[str, Any])
async def get_monitoring_alerts(
    current_user: User = Depends(get_current_user)
):
    """Get summary of monitoring alerts."""
    try:
        alert_summary = monitor.get_alert_summary()
        
        return {
            "status": "success",
            "data": alert_summary,
            "timestamp": datetime.utcnow()
        }
        
    except Exception as e:
        logging.error(f"Alert retrieval error: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Failed to retrieve alerts: {str(e)}")

@app.get("/api/v1/analytics/predictions", response_model=Dict[str, Any])
async def get_prediction_analytics(
    days: int = 7,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Get prediction analytics for the specified number of days."""
    try:
        # Check admin access for detailed analytics
        if current_user.role not in ["admin", "doctor"]:
            raise HTTPException(status_code=403, detail="Insufficient permissions")
        
        # Query prediction logs
        since_date = datetime.utcnow() - timedelta(days=days)
        predictions = db.query(PredictionLog).filter(
            PredictionLog.timestamp >= since_date
        ).all()
        
        # Calculate analytics
        total_predictions = len(predictions)
        risk_distribution = {}
        avg_confidence = 0
        avg_processing_time = 0
        
        if predictions:
            risk_levels = [p.risk_level for p in predictions]
            risk_distribution = {level: risk_levels.count(level) for level in set(risk_levels)}
            avg_confidence = sum(p.confidence for p in predictions) / total_predictions
            avg_processing_time = sum(p.processing_time for p in predictions) / total_predictions
        
        return {
            "status": "success",
            "data": {
                "total_predictions": total_predictions,
                "risk_distribution": risk_distribution,
                "average_confidence": round(avg_confidence, 3),
                "average_processing_time": round(avg_processing_time, 4),
                "period_days": days
            },
            "timestamp": datetime.utcnow()
        }
        
    except Exception as e:
        logging.error(f"Analytics error: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Failed to retrieve analytics: {str(e)}")

@app.get("/api/v1/models/info", response_model=Dict[str, Any])
async def get_model_info(current_user: User = Depends(get_current_user)):
    """Get information about the deployed models."""
    try:
        model_info = {
            "ensemble_model": {
                "status": "active" if hasattr(predictor, 'ensemble') else "inactive",
                "algorithms": ["Random Forest", "XGBoost", "Neural Network"],
                "version": "2.1.0",
                "last_trained": "2024-01-15T10:00:00Z"
            },
            "nlp_model": {
                "status": "active" if nlp_analyzer.nlp else "inactive",
                "language_model": "en_core_web_sm",
                "medical_ner": "biomedical-ner-all",
                "sentiment_model": "cardiffnlp/twitter-roberta-base-sentiment-latest"
            },
            "feature_names": predictor.feature_names if hasattr(predictor, 'feature_names') else [],
            "risk_categories": ["Low Risk", "Medium Risk", "High Risk"]
        }
        
        return {
            "status": "success",
            "data": model_info,
            "timestamp": datetime.utcnow()
        }
        
    except Exception as e:
        logging.error(f"Model info error: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Failed to retrieve model info: {str(e)}")

@app.get("/metrics")
async def get_metrics():
    """Prometheus metrics endpoint."""
    return Response(generate_latest(), media_type="text/plain")

@app.exception_handler(HTTPException)
async def http_exception_handler(request: Request, exc: HTTPException):
    """Custom HTTP exception handler."""
    return JSONResponse(
        status_code=exc.status_code,
        content={
            "status": "error",
            "message": exc.detail,
            "timestamp": datetime.utcnow().isoformat(),
            "path": request.url.path
        }
    )

@app.exception_handler(Exception)
async def general_exception_handler(request: Request, exc: Exception):
    """General exception handler for unhandled errors."""
    logging.error(f"Unhandled exception: {str(exc)}")
    return JSONResponse(
        status_code=500,
        content={
            "status": "error",
            "message": "Internal server error",
            "timestamp": datetime.utcnow().isoformat(),
            "path": request.url.path
        }
    )

# Rate limiting middleware
from slowapi import Limiter, _rate_limit_exceeded_handler
from slowapi.util import get_remote_address
from slowapi.errors import RateLimitExceeded

limiter = Limiter(key_func=get_remote_address)
app.state.limiter = limiter
app.add_exception_handler(RateLimitExceeded, _rate_limit_exceeded_handler)

# Apply rate limiting to prediction endpoints
@limiter.limit("10/minute")
@app.post("/api/v1/predict-limited")
async def predict_risk_limited(request: Request, patient_data: PatientData, 
                              current_user: User = Depends(get_current_user)):
    """Rate-limited prediction endpoint for high-volume usage."""
    return await predict_risk(patient_data, BackgroundTasks(), request, current_user, get_db())

# WebSocket support for real-time updates
from fastapi import WebSocket, WebSocketDisconnect
import json

class ConnectionManager:
    def __init__(self):
        self.active_connections: List[WebSocket] = []
    
    async def connect(self, websocket: WebSocket):
        await websocket.accept()
        self.active_connections.append(websocket)
    
    def disconnect(self, websocket: WebSocket):
        self.active_connections.remove(websocket)
    
    async def send_personal_message(self, message: str, websocket: WebSocket):
        await websocket.send_text(message)
    
    async def broadcast(self, message: str):
        for connection in self.active_connections:
            try:
                await connection.send_text(message)
            except:
                # Connection closed, remove it
                self.active_connections.remove(connection)

manager = ConnectionManager()

@app.websocket("/ws/alerts")
async def websocket_endpoint(websocket: WebSocket):
    """WebSocket endpoint for real-time alerts."""
    await manager.connect(websocket)
    try:
        while True:
            # Keep connection alive and send periodic updates
            await asyncio.sleep(30)
            
            # Send alert summary
            alert_summary = monitor.get_alert_summary()
            await manager.send_personal_message(
                json.dumps({
                    "type": "alert_summary",
                    "data": alert_summary,
                    "timestamp": datetime.utcnow().isoformat()
                }),
                websocket
            )
            
    except WebSocketDisconnect:
        manager.disconnect(websocket)

if __name__ == "__main__":
    # Production configuration
    config = {
        "host": "0.0.0.0",
        "port": 8000,
        "workers": 4,
        "log_level": "info",
        "access_log": True,
        "use_colors": True,
        "reload": False  # Set to True for development
    }
    
    uvicorn.run("api.main:app", **config)
